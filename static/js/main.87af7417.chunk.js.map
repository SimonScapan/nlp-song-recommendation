{"version":3,"sources":["App.js","databasehandler.js","index.js"],"names":["allSongs","Object","values","response","$","ajax","url","Database_url","dataType","type","async","success","serverResponse","error","console","log","Error","getAllSongs","sort","e1","e2","object1","object2","key","obj1","toUpperCase","obj2","compareObjects","App","useState","song_title","selectedSong","setSelectedSong","suggestionResults","setSuggestionResults","generateSuggestion","songSuggestions","songInformations","forEach","song","sentimentError","array1","array2","i","length","j","findCommonElement","song_genre","Math","abs","happy","angry","surprise","sad","fear","push","returnSongs","inbdexOfSmallestError","allSongs_tmp_copy","slice","index","indexOf","min","apply","splice","getSongSuggestions","nameKey","myArray","searchSonginformation","className","style","textAlign","Autocomplete","id","options","getOptionLabel","option","renderInput","params","TextField","label","variant","width","marginLeft","marginRight","onChange","e","target","innerHTML","onClick","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.87af7417.chunk.js","sourcesContent":["import React, { useState } from 'react';\r\nimport Autocomplete from '@material-ui/lab/Autocomplete'\r\nimport TextField from '@material-ui/core/TextField'\r\nimport './App.css';\r\nimport { getAllSongs } from \"./databasehandler\"\r\n\r\n// function from https://www.codegrepper.com/code-examples/javascript/sort+an+array+of+dictionaries+elements+javascript\r\nlet compareObjects = (object1, object2, key) => {\r\n  const obj1 = object1[key].toUpperCase()\r\n  const obj2 = object2[key].toUpperCase()\r\n\r\n  if (obj1 < obj2) {\r\n    return -1\r\n  }\r\n  if (obj1 > obj2) {\r\n    return 1\r\n  }\r\n  return 0\r\n}\r\n\r\n\r\n// Initially load all songs from db on pageload.\r\nlet allSongs = Object.values(getAllSongs());\r\n  allSongs.sort((e1, e2) => {\r\n  return compareObjects(e1, e2, 'song_title')\r\n})\r\n\r\nfunction App() {\r\n  // function state for selectedSong and suggestes Songs\r\n  const [selectedSong, setSelectedSong] = useState({ song_title: \"\" });\r\n  const [suggestionResults, setSuggestionResults] = useState([{ song_title: \"\" }, { song_title: \"\" }, { song_title: \"\" }]);\r\n\r\n  // searchSonginformation for whole songinformation for given title. Assumption: Songtitles are unique. \r\n  let searchSonginformation = (nameKey, myArray) => {\r\n    for (var i = 0; i < myArray.length; i++) {\r\n      if (myArray[i].song_title === nameKey.song_title) {\r\n        return myArray[i];\r\n      }\r\n    }\r\n  }\r\n\r\n  // check if arrays have common elements.\r\n  let findCommonElement = (array1, array2) => {\r\n    // Loop trough both arrays\r\n    for (let i = 0; i < array1.length; i++) {\r\n      for (let j = 0; j < array2.length; j++) {\r\n        // if elements matching, return true\r\n        if (array1[i] === array2[j]) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    // If not match was found, return false \r\n    return false;\r\n  }\r\n\r\n  // genereate song suggestion based on given songinformations\r\n  let getSongSuggestions = (songInformations) => {\r\n    let error = []\r\n    // songInformation entity:\r\n    // {angry: 0.15, fear: 0.08, genre: 0, happy: 0, interpret: \"['Uli']\", …}\r\n    // Loop trough all songs and calculate error for each song based on absolute difference.\r\n    allSongs.forEach(function (song) {\r\n      let sentimentError = 0\r\n      // We don't want the same song or songs from different genre as suggestion. Thats why we give those songs high error Values.\r\n      if (song.song_title == songInformations.song_title || findCommonElement(song.song_genre, songInformations.song_genre)\r\n      ) {\r\n        sentimentError = 100000000000\r\n        // This block sums up all errors (absolute differences) between given song and currently inspected song \r\n        // from all songs and saves this error as sentimentError into the error-list.\r\n      } else {\r\n        sentimentError += Math.abs(song.happy - songInformations.happy)\r\n        sentimentError += Math.abs(song.angry - songInformations.angry)\r\n        sentimentError += Math.abs(song.surprise - songInformations.surprise)\r\n        sentimentError += Math.abs(song.sad - songInformations.sad)\r\n        sentimentError += Math.abs(song.fear - songInformations.fear)\r\n      }\r\n      error.push(sentimentError)\r\n    });\r\n\r\n    // The list retunSongs will now be filled with 3 smallest error songs.\r\n    let returnSongs = []\r\n    let inbdexOfSmallestError = 0\r\n    let allSongs_tmp_copy = allSongs.slice(0, -1)\r\n    for (let index = 0; index < 3; index++) {\r\n      inbdexOfSmallestError = error.indexOf(Math.min.apply(Math, error));\r\n      returnSongs.push(allSongs_tmp_copy.splice(inbdexOfSmallestError, 1)[0])\r\n    }\r\n    return returnSongs\r\n  }\r\n\r\n\r\n  let generateSuggestion = () => {\r\n    // get current song informations.\r\n    let currentSongInformations = searchSonginformation(selectedSong, allSongs)\r\n    // get song suggestion based on current song informations.\r\n    let songSuggestions = getSongSuggestions(currentSongInformations)\r\n    // set song suggestion into suggestionResults.\r\n    setSuggestionResults(songSuggestions)\r\n  }\r\n\r\n  // Display necessary input on website.\r\n  return (\r\n    <div className=\"App\" style={{ textAlign: \"center\" }}>\r\n      <h1 style={{ textAlign: \"center\" }}>Songtiteleingabe:</h1>\r\n      <Autocomplete\r\n        id=\"combo-box-demo\"\r\n        options={allSongs}\r\n        getOptionLabel={(option) => option.song_title}\r\n        renderInput={(params) => <TextField {...params} label=\"Combo box\" variant=\"outlined\" />}\r\n        style={{\r\n          width: 300,\r\n          marginLeft: \"auto\",\r\n          marginRight: \"auto\"\r\n        }}\r\n        onChange={(e) => { setSelectedSong({ song_title: e.target.innerHTML }) }}\r\n      />\r\n      <button\r\n        onClick={() => { generateSuggestion() }}\r\n        style={{\r\n          marginLeft: \"auto\",\r\n          marginRight: \"auto\"\r\n        }}>\r\n        {\"Vorschlag generieren\"}\r\n      </button>\r\n      <p style={{ textAlign: \"center\" }}>Songvorschlag:</p>\r\n      <p style={{ textAlign: \"center\" }}>{suggestionResults[0].song_title}</p>\r\n      <p style={{ textAlign: \"center\" }}>{suggestionResults[1].song_title}</p>\r\n      <p style={{ textAlign: \"center\" }}>{suggestionResults[2].song_title}</p>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import $ from 'jquery';\r\n// URL to firebase-db\r\nconst Database_url = \"https://murat-db-20-default-rtdb.firebaseio.com/\"\r\n\r\n// function to get all songs from firebase db\r\nexport function getAllSongs() {\r\n    let response\r\n    $.ajax({\r\n        url: Database_url + '.json',\r\n        dataType: \"json\",\r\n        type: 'GET',\r\n        async: false,\r\n        success: function (serverResponse) {\r\n            // console.log(serverResponse)\r\n            response = serverResponse;\r\n        },\r\n        error: function (serverResponse) {\r\n            console.log(\"Errorlog: Response: \", serverResponse);\r\n            response = serverResponse;\r\n            debugger;\r\n            throw new Error(\"Error during loading of all songs\");\r\n        }\r\n    });\r\n    return response\r\n}","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport App from './App';\n\nReactDOM.render(<App/>, document.getElementById(\"root\"))"],"sourceRoot":""}